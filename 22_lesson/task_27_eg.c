/* Задача No27 ЕГЭ по информатике
На вход программы поступает последовательность из N целых положительных чисел,
все числа в последовательности различны. Рассматриваются все пары различных
элементов последовательности (элементы пары не обязаны стоять в
последовательности рядом, порядок элементов в паре не важен). Необходимо
определить количество пар, для которых произведение элементов делится на 26.
Описание входных и выходных данных
В первой строке входных данных задаётся количество чисел N (1 ≤ N ≤ 1000). В
каждой из последующих N строк записано одно целое положительное число, не
превышающее 10 000. В качестве результата программа должна напечатать одно
число: количество пар, в которых произведение элементов кратно 26. Пример
входных данных: 4  2 6 13 39 Пример выходных данных для приведённого выше примера
входных данных: 4 Пояснение. Из четырёх заданных чисел можно составить 6
попарных произведений: 2-6, 2-13, 2-39, 6-13, 6-39, 13-39 (результаты: 12, 26,
78, 78, 234, 507). Из них на 26 делятся 4 произведения (2·13=26; 2·39=78;
6·13=78; 6·39=234).

Требуется написать эффективную по времени и по памяти программу для решения
описанной задачи. Программа считается эффективной по времени, если при
увеличении количества исходных чисел N в к раз время работы программы
увеличивается не более чем в к раз. Программа считается эффективной по памяти,
если память, необходимая для хранения всех переменных программы, не превышает 1
Кбайт и не увеличивается с ростом N.
*/

#include <stdio.h>

int main() {
  int N, k26 = 0, k13 = 0, k2 = 0, k1 = 0;
  scanf("%d", &N);

  for (int i = 0; i < N; i++) {
    int x;
    scanf("%d", &x);

    if (x % 26 == 0) {
        k26++;
    } else if (x % 13 == 0) {
        k13++;
    } else if (x % 2 == 0) {
        k2++;
    } else {
        k1++;
    }
  }

  int m = k26 * (k26 - 1) / 2 + k26 * (k1 + k2 + k13) + k2 * k13;
  printf("%d\n", m);

  return 0;
}

/* Не ресурсоэффективная программа
int main(){
    int N;
    scanf("%d", &N);
    int A[N];

    for (int i = 0; i < N; i++)
    {
	scanf("%d", &A[i]);
    }
    int m = 0;

    for (int i = 0; i < N; i++) {
	    for (int k = i+1; k < N; k++) {
	        if (A[i]*A[k]%26 == 0) {
		        m++;
	        }
        }
    }
    printf("%d\n", m);

    return 0;
}
*/
